import os
import json
import csv
import shutil
import alive_progress
import requests
import time
import sys
import hashlib
import re
from modules.misc import *
from pathlib import Path


class ExploitDb:
    def __init__(self):
        """
        Default constrictor.
        :param:
        :return:
        """
        self.cve_to_exploit_mapping = {}
        self.current_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
        self.edbid_to_cve_file = self.current_path + "/data/edbidToCve.json"
        self.cve_to_edbid_file = self.current_path + "/data/cveToEdbid.json"
        self.edbid_to_cve_file_backup = self.current_path + "/data/.edbidToCve.json.bak"
        self.cve_to_edbid_file_backup = self.current_path + "/data/.cveToEdbid.json.bak"
        self.edbid_to_cve_file_hash_path = self.current_path + "/data/.edbidToCve.json.sha256"
        self.cve_to_edbid_file_hash_path = self.current_path + "/data/.cveToEdbid.json.sha256"
        self.exploit_db_path = self.current_path + "/data/exploit-database"
        self.request_cool_off_time = 1
        self.debug = False
        self.auto_update = False
        self.headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, '
                                      'like Gecko) Chrome/39.0.2171.95 Safari/537.36'}

    def open_file(self, exploit_map="cveToEdbid.json", encoding="utf-8"):
        """
        Loads the cveToEdbid.json file
        :param exploit_map:
        :param encoding:
        :return:
        """
        if not os.path.isdir(self.exploit_db_path):
            # Downloads exploit-db from github if it does not exists
            try:
                print(print_yellow("[+] Downloading exploit-database"))
                git.Repo.clone_from("https://github.com/offensive-security/exploit-database.git", self.exploit_db_path,
                                    progress=CloneProgress())
                if not os.path.exists(self.cve_to_edbid_file) and not os.path.exists(self.edbid_to_cve_file):
                    self.update_db()
                else:
                    with open(self.current_path + "/data/" + exploit_map, encoding="utf-8") as file_data:
                        cve_to_exploit_map = json.load(file_data)
                        self.cve_to_exploit_mapping = cve_to_exploit_map
                        if self.debug is True:
                            print(self.cve_to_exploit_mapping)
            except:
                print(print_red("[!] Could not download exploit-database"))
                sys.exit(1)

        else:
            if self.auto_update is True:
                # Checks commit differences to determine if local files are outdated
                try:
                    repo = git.Repo(self.exploit_db_path)
                    current = repo.head.commit
                    repo.remotes.origin.pull()
                    if current != repo.head.commit:
                        print(print_yellow("[+] Updating exploit-database"))
                        git.Git(self.exploit_db_path).pull('origin', 'master')
                        self.update_db()
                        hash_result = self.sha256(self.cve_to_edbid_file)
                        self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                        hash_result = self.sha256(self.edbid_to_cve_file)
                        self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                        self.backup_files()
                    else:
                        print(print_green("[!] exploit-database up-to-date"))
                except:
                    # Fallback to use existing files
                    print(print_red("[!] Could not update exploit-db, using existing installation"))

            try:
                # if built json files are deleted try to restore using backup files
                if not os.path.exists(self.edbid_to_cve_file):
                    if os.path.exists(self.edbid_to_cve_file_backup) and os.path.exists(self.cve_to_edbid_file_backup):
                        self.restore_files()
                        hash_result = self.sha256(self.cve_to_edbid_file)
                        self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                        hash_result = self.sha256(self.edbid_to_cve_file)
                        self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                    else:
                        self.update_db()
                        hash_result = self.sha256(self.cve_to_edbid_file)
                        self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                        hash_result = self.sha256(self.edbid_to_cve_file)
                        self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                        self.backup_files()

                # if files do not match the sha256 checksum
                if not self.check_integrity():
                    self.restore_files()
                    hash_result = self.sha256(self.cve_to_edbid_file)
                    self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                    hash_result = self.sha256(self.edbid_to_cve_file)
                    self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                    # check restored files
                    if not self.check_integrity():
                        raise Exception("Restoration failed")

                # open the json files
                with open(self.current_path + "/data/" + exploit_map, encoding="utf-8") as file_data:
                    cve_to_exploit_map = json.load(file_data)
                    self.cve_to_exploit_mapping = cve_to_exploit_map
                    if self.debug is True:
                        print(self.cve_to_exploit_mapping)

            except:
                try:
                    self.update_db()
                    hash_result = self.sha256(self.cve_to_edbid_file)
                    self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                    hash_result = self.sha256(self.edbid_to_cve_file)
                    self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                    self.backup_files()
                except:
                    print(print_red("[!] Something went wrong, connect to the internet and run the program again"))
                    sys.exit(1)

    def sha256(self, arg_file):
        """
        Hash files using SHA256
        :param arg_file:
        :return file_hash.hexdigest():
        """
        file_hash = hashlib.sha256()
        with open(arg_file, "rb") as f:
            fb = f.read(65536)
            while len(fb) > 0:
                file_hash.update(fb)
                fb = f.read(65536)
        return file_hash.hexdigest()

    def write_hash(self, arg_file, hex_digest):
        """
        Write the hash into a file
        :param arg_file:
        :param hex_digest:
        :return:
        """
        with open(arg_file, "w") as f:
            f.write(hex_digest)

    def check_integrity(self):
        """
        Checks the integrity of the two json files.
        :return True:
        :return False:
        """
        cve_to_edbid_file_hash = self.sha256(self.cve_to_edbid_file)
        edbid_to_cve_file_hash = self.sha256(self.edbid_to_cve_file)
        first_check = False
        second_check = False
        filename = self.cve_to_edbid_file_hash_path
        with open(filename, "r") as f:
            if f.read() == cve_to_edbid_file_hash:
                first_check = True
        filename = self.edbid_to_cve_file_hash_path
        with open(filename, "r") as f:
            if f.read() == edbid_to_cve_file_hash:
                second_check = True
        if first_check and second_check:
            return True
        else:
            return False

    def get_cve_details(self, cve_search):
        """
        Open files_exploits.csv and search the cve
        :param cve_search:
        :return result:
        """
        files = open(self.current_path + "/data/exploit-database/files_exploits.csv", encoding="utf-8")
        reader = csv.reader(files)
        next(reader)
        result = {}
        found = False
        for row in reader:
            edb, file_name, description, date, author, platform, exploit_type, port = tuple(row)
            if edb in self.cve_to_exploit_mapping[cve_search]:
                found = True
                result['edbid'] = edb
                result['exploit'] = self.exploit_db_path + "/" + file_name
                result['date'] = date
                result['author'] = author
                result['platform'] = platform
                result['type'] = exploit_type
                if self.debug is True:
                    print(print_yellow("Exploit DB Id: %s" % edb))
                    print(print_yellow("File: %s/%s" % (self.exploit_db_path, file_name)))
                    print(print_yellow("Date: %s" % date))
                    print(print_yellow("Author: %s" % author))
                    print(print_yellow("Platform: %s" % platform))
                    print(print_yellow("Type: %s" % exploit_type))
                if port != "0":
                    result['port'] = port
                    if self.debug is True:
                        print(print_yellow("Port: %s" % port))
        if not found:
            if self.debug is True:
                print("[!] ERROR - No EDB Id found")
        files.close()
        return result

    def search_cve(self, cve_search):
        """
        Search via CVE
        :param cve_search:
        :return cve_data:
        :return cve_search:
        :return []:
        """
        if not cve_search:
            return []
        cve_search = cve_search.upper()
        if self.debug is True:
            print(cve_search)
        if cve_search in self.cve_to_exploit_mapping:
            if self.debug is True:
                print(print_yellow("Found"))
            cve_data = self.get_cve_details(cve_search)
            if cve_data:
                return cve_data
            else:
                return cve_search
        return []

    def locations_of_substring(self, string, substring):
        """
        :param string:
        :param substring:
        :return results:
        """
        results = [m.start() for m in re.finditer(substring, string)]
        return results

    def update_db(self):
        """
        Update the json files
        :param:
        :return None:
        """
        # check if files exists
        if not os.path.exists(self.edbid_to_cve_file):
            if os.path.exists(self.edbid_to_cve_file_backup) and os.path.exists(self.cve_to_edbid_file_backup):
                self.restore_files()
                hash_result = self.sha256(self.cve_to_edbid_file)
                self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                hash_result = self.sha256(self.edbid_to_cve_file)
                self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                with open(self.edbid_to_cve_file, encoding="utf-8") as file_data:
                    data = json.load(file_data)
            else:
                Path(self.edbid_to_cve_file).touch()
                data = {}

        # if exist open
        else:
            # check integrity first
            if not self.check_integrity():
                self.restore_files()
                hash_result = self.sha256(self.cve_to_edbid_file)
                self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                hash_result = self.sha256(self.edbid_to_cve_file)
                self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                # check restored files
                if not self.check_integrity():
                    raise Exception("Restoration failed")
            with open(self.edbid_to_cve_file, encoding="utf-8") as file_data:
                try:
                    data = json.load(file_data)
                except:
                    self.restore_files()
                    hash_result = self.sha256(self.cve_to_edbid_file)
                    self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                    hash_result = self.sha256(self.edbid_to_cve_file)
                    self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                    try:
                        data = json.load(file_data)
                    except:
                        print(print_red("[!] Possibly corrupt or empty: %s" % self.edbid_to_cve_file))
                        os.remove(self.edbid_to_cve_file)
                        Path(self.edbid_to_cve_file).touch()
                        data = {}

        files = open(self.exploit_db_path + "/files_exploits.csv", encoding="utf-8")
        reader = csv.reader(files)
        next(reader)
        reader = list(reader)
        edb_count = len(reader)
        print(print_yellow("[!] Refreshing EDBID-CVE mapping. This may take a long time."))
        with alive_progress.alive_bar(edb_count) as bar:
            for i in range(edb_count):
                edb = tuple(reader[i])[0]
                if edb in data:
                    if self.debug is True:
                        print("[!] Skipping %s" % str(edb))
                        pass
                # content does not exist in the file
                else:
                    content = ""
                    while True:
                        try:
                            request_uri = "https://www.exploit-db.com/exploits/%s" % str(edb)
                            if self.debug is True:
                                print("[!] Requesting %s" % request_uri)
                            r = requests.get(request_uri, headers=self.headers, timeout=10)
                            content = r.content.decode("ISO-8859-1")
                        except Exception as e:
                            if self.debug is True:
                                print("[!] Error %s" % e)
                            time.sleep(self.request_cool_off_time)
                            continue
                        finally:
                            break
                    indexes = self.locations_of_substring(content, 'https://nvd.nist.gov/vuln/detail/CVE-')
                    used = []
                    for pos in indexes:
                        cve = r.content[pos + 33: pos + 33 + 14]
                        if isinstance(cve, bytes):
                            cve = cve.decode("ISO-8859-1")
                        cve = cve.replace('\"', '')
                        cve = cve.replace('\r', '')
                        cve = cve.replace('\n', '')
                        if cve in used:
                            continue
                        used.append(cve)
                    data[edb] = used
                    with open(self.edbid_to_cve_file, "w", encoding="utf-8") as file_data:
                        json.dump(data, file_data, indent=2)
                    self.cve_to_exploit_mapping = {}
                    for k, v in data.items():
                        for e in v:
                            self.cve_to_exploit_mapping[e] = self.cve_to_exploit_mapping.get(e, [])
                            self.cve_to_exploit_mapping[e].append(k)
                    with open(self.cve_to_edbid_file, "w", encoding="utf-8") as file_data:
                        json.dump(self.cve_to_exploit_mapping, file_data, indent=2)
                time.sleep(0.005)
                bar()

    def search_keyword(self, keyword):
        """
        Search via keywords
        :param keyword:
        :return cve_data:
        :return []]:
        """
        result_list = []
        if not keyword:
            return []
        print(keyword)
        files = open(self.exploit_db_path + "/files_exploits.csv", encoding="utf-8")
        reader = csv.reader(files)
        next(reader)
        reader = list(reader)
        edb_count = len(reader)
        files.close()
        for i in range(edb_count):
            result = tuple(reader[i])[2]
            edb = tuple(reader[i])[0]
            if keyword.lower() in result.lower():
                if self.debug is True:
                    print(print_green("Found"))
                result_list.append(edb)
        cve_data = self.get_details_list(result_list)
        if cve_data:
            return cve_data
        else:
            return []

    def get_details_list(self, id_list):
        """
        :param id_list:
        :return result:
        """
        result = []
        for i in id_list:
            edbid_data = self.get_edbid_details(i)
            result.append(edbid_data)
        return result

    def get_edbid_details(self, edbid):
        """
        Get edbid details
        :param edbid:
        :return result:
        """
        files = open(self.current_path + "/data/exploit-database/files_exploits.csv", encoding="utf-8")
        reader = csv.reader(files)
        next(reader)
        result = []
        for row in reader:
            edb, file_name, description, date, author, platform, exploit_type, port = tuple(row)
            if edbid == edb:
                result.append(row)
        files.close()
        return result

    def backup_files(self):
        """
        Backup json files
        :param:
        :return:
        """
        shutil.copyfile(self.edbid_to_cve_file, self.edbid_to_cve_file_backup)
        shutil.copyfile(self.cve_to_edbid_file, self.cve_to_edbid_file_backup)

    def restore_files(self):
        """
        Restore json files
        :param:
        :return:
        """
        shutil.copyfile(self.edbid_to_cve_file_backup, self.edbid_to_cve_file)
        shutil.copyfile(self.cve_to_edbid_file_backup, self.cve_to_edbid_file)

    def force_update(self):
        """
        Update all files
        :param:
        :return:
        """
        # Checks commit differences to determine if local files are outdated
        if not os.path.isdir(self.exploit_db_path):
            try:
                print(print_yellow("[+] Downloading exploit-database"))
                git.Repo.clone_from("https://github.com/offensive-security/exploit-database.git", self.exploit_db_path,
                                    progress=CloneProgress())
                self.update_db()
            except:
                print(print_red("[!] Could not download exploit-database"))
                sys.exit(1)
        else:
            try:
                repo = git.Repo(self.exploit_db_path)
                current = repo.head.commit
                repo.remotes.origin.pull()
                if current != repo.head.commit:
                    print(print_yellow("[+] Updating exploit-database"))
                    git.Git(self.exploit_db_path).pull('origin', 'master')
                    self.update_db()
                    hash_result = self.sha256(self.cve_to_edbid_file)
                    self.write_hash(self.cve_to_edbid_file_hash_path, hash_result)
                    hash_result = self.sha256(self.edbid_to_cve_file)
                    self.write_hash(self.edbid_to_cve_file_hash_path, hash_result)
                    self.backup_files()
                else:
                    print(print_green("[!] exploit-database up-to-date"))
            except:
                # Fallback to use existing files
                print(print_red("[!] Could not update exploit-db, using existing installation"))

    def run(self, cve_list):
        """
        :param cve_list:
        :return True:
        :return results:
        :return False:
        :return None:
        """
        self.open_file()
        for cve in cve_list:
            if cve.upper().startswith("CVE-"):
                results = self.search_cve(cve)
                if results:
                    print(print_green("\n[!] " + cve + " Found! Getting the exploit PoC."))
                    exploit_name = results["exploit"].rsplit("/", 1)[-1]
                    shutil.copyfile(results["exploit"], self.current_path + "/downloads/" + exploit_name)
                    if os.path.exists(self.current_path + "/downloads/" + exploit_name):
                        pass
                    else:
                        try:
                            download_url = "https://www.exploit-db.com/download/%s" % results["edbid"]
                            r = requests.get(download_url, headers=self.headers, timeout=10)
                            path = "%s/downloads/%s" % (self.current_path, results["exploit"].rsplit("/", 1)[-1])
                            with open(path, "wb") as f:
                                f.write(r.content)
                        except:
                            print(print_red("[!] Failed to download"))
                            return False, None
                    return True, results["exploit"]
                else:
                    print(print_red("[!] Failed to get " + cve))
                    return False, None

            # Potential expansion for future feature
            else:
                results = self.search_keyword(cve)
                if results:
                    for i in results:
                        print(i)
                    print(results)
                    return True, results
                else:
                    print(print_red("[!] Failed to get " + cve))
                    return False, None
