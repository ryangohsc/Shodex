# Credits: Based on pyExploitDb taken from https://github.com/GoVanguard/pyExploitDb
# Improvement, fixes and additions of features has been made by a team member of pizzaluvers
import os
import json
import csv
import alive_progress
from alive_progress import alive_bar
import requests
import time
import sys
import git
import hashlib
import re


cve_to_exploit_mapping = {}
current_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
edbid_to_cve_file = current_path + "/data/edbidToCve.json"
cve_to_edbid_file = current_path + "/data/cveToEdbid.json"
edbid_to_cve_file_backup = current_path + "/data/.edbidToCve.json.bak"
cve_to_edbid_file_backup = current_path + "/data/.cveToEdbid.json.bak"
edbid_to_cve_file_hash_path = current_path + "/data/.edbidToCve.json.sha256"
cve_to_edbid_file_hash_path = current_path + "/data/.cveToEdbid.json.sha256"
exploit_db_path = current_path + "/data/exploit-database"
request_cool_off_time = 1
debug = False
auto_update = False
headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) '
                         'Chrome/39.0.2171.95 Safari/537.36'}


class CloneProgress(git.RemoteProgress):
    def __init__(self):
        super().__init__()
        self.alive_bar_instance = None

    def update(self, op_code, cur_count, max_count=None, message=''):
        self.alive_bar_instance.total = max_count
        self.alive_bar_instance.n = cur_count
        self.alive_bar_instance.refresh()


def open_file(exploit_map="cveToEdbid.json", encoding="utf-8"):
    """
    Loads the cveToEdbid.json file
    :param exploit_map:
    :param encoding:
    :return: None
    """
    if not os.path.isdir(exploit_db_path):
        # Downloads exploit-db from github if it does not exists
        try:
            print("[+] Downloading exploit-database")
            git.Repo.clone_from("https://github.com/offensive-security/exploit-database.git", exploit_db_path, progress=CloneProgress())
            update_db()
        except:
            print("[!] Could not download exploit-database")
            sys.exit(1)
    else:
        if auto_update is True:
            # Checks commit differences to determine if local files are outdated
            try:
                repo = git.Repo(exploit_db_path)
                current = repo.head.commit
                repo.remotes.origin.pull()
                if current != repo.head.commit:
                    print("[+] Updating exploit-database")
                    git.Git(exploit_db_path).pull('origin', 'master')
                    update_db()
                    hash_result = sha256(cve_to_edbid_file)
                    write_hash(cve_to_edbid_file_hash_path, hash_result)
                    hash_result = sha256(edbid_to_cve_file)
                    write_hash(edbid_to_cve_file_hash_path, hash_result)
                    backup_files()
                else:
                    print("[!] exploit-database up-to-date")
            except:
                # Fallback to use existing files
                print("[!] Could not update exploit-db, using existing installation")
        try:
            # if built json files are deleted try to restore using backup files
            if not os.path.exists(edbid_to_cve_file):
                if os.path.exists(edbid_to_cve_file_backup) and os.path.exists(cve_to_edbid_file_backup):
                    restore_files()
                    hash_result = sha256(cve_to_edbid_file)
                    write_hash(cve_to_edbid_file_hash_path, hash_result)
                    hash_result = sha256(edbid_to_cve_file)
                    write_hash(edbid_to_cve_file_hash_path, hash_result)
                else:
                    update_db()
                    hash_result = sha256(cve_to_edbid_file)
                    write_hash(cve_to_edbid_file_hash_path, hash_result)
                    hash_result = sha256(edbid_to_cve_file)
                    write_hash(edbid_to_cve_file_hash_path, hash_result)
                    backup_files()
            # if files do not match the sha256 checksum
            if not check_integrity():
                restore_files()
                hash_result = sha256(cve_to_edbid_file)
                write_hash(cve_to_edbid_file_hash_path, hash_result)
                hash_result = sha256(edbid_to_cve_file)
                write_hash(edbid_to_cve_file_hash_path, hash_result)
                # check restored files
                if not check_integrity():
                    raise Exception("Restoration failed")
            # open the json files
            with open(current_path + "/data/" + exploit_map, encoding="utf-8") as file_data:
                cve_to_exploit_map = json.load(file_data)
                global cve_to_exploit_mapping
                cve_to_exploit_mapping = cve_to_exploit_map
                if debug is True:
                    print(cve_to_exploit_mapping)
        except:
            try:
                update_db()
                hash_result = sha256(cve_to_edbid_file)
                write_hash(cve_to_edbid_file_hash_path, hash_result)
                hash_result = sha256(edbid_to_cve_file)
                write_hash(edbid_to_cve_file_hash_path, hash_result)
                backup_files()
            except:
                print("[!] Something went wrong, connect to the internet and run the program again")
                sys.exit(1)


def sha256(arg_file):
    """
    Hash files using SHA256
    :param arg_file:
    :return: file_hash.hexdigest()
    """
    file_hash = hashlib.sha256()
    with open(arg_file, "rb") as f:
        fb = f.read(65536)
        while len(fb) > 0:
            file_hash.update(fb)
            fb = f.read(65536)
    return file_hash.hexdigest()


def write_hash(arg_file, hex_digest):
    """
    Write the hash into a file
    :param arg_file:
    :param hex_digest:
    :return: None
    """
    with open(arg_file, "w") as f:
        f.write(hex_digest)


def check_integrity():
    """
    Checks the integrity of the two json files
    :return: True or False
    """
    cve_to_edbid_file_hash = sha256(cve_to_edbid_file)
    edbid_to_cve_file_hash = sha256(edbid_to_cve_file)
    first_check = False
    second_check = False
    filename = cve_to_edbid_file_hash_path
    with open(filename, "r") as f:
        if f.read() == cve_to_edbid_file_hash:
            first_check = True
    filename = edbid_to_cve_file_hash_path
    with open(filename, "r") as f:
        if f.read() == edbid_to_cve_file_hash:
            second_check = True
    if first_check and second_check:
        return True
    else:
        return False


def get_cve_details(cve_search):
    """
    Open files_exploits.csv and search the cve
    :param cve_search:
    :return: result
    """
    files = open(current_path + "/data/exploit-database/files_exploits.csv", encoding="utf-8")
    reader = csv.reader(files)
    next(reader)
    result = {}
    found = False
    for row in reader:
        edb, file_name, description, date, author, platform, exploit_type, port = tuple(row)
        if edb in cve_to_exploit_mapping[cve_search]:
            found = True
            result['edbid'] = edb
            result['exploit'] = exploit_db_path + "/" + file_name
            result['date'] = date
            result['author'] = author
            result['platform'] = platform
            result['type'] = exploit_type
            if debug is True:
                print("Exploit DB Id: %s" % edb)
                print("File: %s/%s" % (exploit_db_path, file_name))
                print("Date: %s" % date)
                print("Author: %s" % author)
                print("Platform: %s" % platform)
                print("Type: %s" % exploit_type)
            if port != "0":
                result['port'] = port
                if debug is True:
                    print("Port: %s" % port)
    if not found:
        if debug is True:
            print("[!] ERROR - No EDB Id found")
    files.close()
    return result


def search_cve(cve_search):
    """
    Search via CVE
    :param cve_search:
    :return: cve_data, cve_search, []
    """
    if not cve_search:
        return []
    cve_search = cve_search.upper()
    if debug is True:
        print(cve_search)
    if cve_search in cve_to_exploit_mapping:
        if debug is True:
            print("Found")
        cve_data = get_cve_details(cve_search)
        if cve_data:
            return cve_data
        else:
            return cve_search
    return []


def locations_of_substring(string, substring):
    """
    :param string:
    :param substring:
    :return: results
    """
    results = [m.start() for m in re.finditer(substring, string)]
    return results


def update_db():
    """
    Update the json files
    :return: None
    """
    data = {}
    # check if files exists
    if not os.path.exists(edbid_to_cve_file):
        if os.path.exists(edbid_to_cve_file_backup) and os.path.exists(cve_to_edbid_file_backup):
            restore_files()
            hash_result = sha256(cve_to_edbid_file)
            write_hash(cve_to_edbid_file_hash_path, hash_result)
            hash_result = sha256(edbid_to_cve_file)
            write_hash(edbid_to_cve_file_hash_path, hash_result)
            with open(edbid_to_cve_file, encoding="utf-8") as file_data:
                data = json.load(file_data)
        else:
            os.system("touch %s" % edbid_to_cve_file)
            data = {}
    # if exist open
    else:
        # check integrity first
        if not check_integrity():
            restore_files()
            hash_result = sha256(cve_to_edbid_file)
            write_hash(cve_to_edbid_file_hash_path, hash_result)
            hash_result = sha256(edbid_to_cve_file)
            write_hash(edbid_to_cve_file_hash_path, hash_result)
            # check restored files
            if not check_integrity():
                raise Exception("Restoration failed")
        with open(edbid_to_cve_file, encoding="utf-8") as file_data:
            try:
                data = json.load(file_data)
            except:
                restore_files()
                hash_result = sha256(cve_to_edbid_file)
                write_hash(cve_to_edbid_file_hash_path, hash_result)
                hash_result = sha256(edbid_to_cve_file)
                write_hash(edbid_to_cve_file_hash_path, hash_result)
                try:
                    data = json.load(file_data)
                except:
                    print("[!] Possibly corrupt or empty: %s" % edbid_to_cve_file)
                    os.system("rm -f %s" % edbid_to_cve_file)
                    os.system("touch %s" % edbid_to_cve_file)
                    data = {}

    files = open(exploit_db_path + "/files_exploits.csv", encoding="utf-8")
    reader = csv.reader(files)
    next(reader)
    reader = list(reader)
    edb_count = len(reader)
    print("[!] Refreshing EDBID-CVE mapping. This may take a long time.")
    with alive_progress.alive_bar(edb_count) as bar:
        for i in range(edb_count):
            edb = tuple(reader[i])[0]
            if edb in data:
                if debug is True:
                    print("[!] Skipping %s" % str(edb))
                    pass
            # content does not exist in the file
            else:
                content = ""
                while True:
                    try:
                        request_uri = "https://www.exploit-db.com/exploits/%s" % str(edb)
                        if debug is True:
                            print("[!] Requesting %s" % request_uri)
                        r = requests.get(request_uri, headers=headers, timeout=10)
                        content = r.content.decode("ISO-8859-1")
                    except Exception as e:
                        if debug is True:
                            print("[!] Error %s" % e)
                        time.sleep(request_cool_off_time)
                        continue
                    finally:
                        break
                indexes = locations_of_substring(content, 'https://nvd.nist.gov/vuln/detail/CVE-')
                used = []
                for pos in indexes:
                    cve = r.content[pos + 33: pos + 33 + 14]
                    if isinstance(cve, bytes):
                        cve = cve.decode("ISO-8859-1")
                    cve = cve.replace('\"', '')
                    cve = cve.replace('\r', '')
                    cve = cve.replace('\n', '')
                    if cve in used:
                        continue
                    used.append(cve)
                data[edb] = used
                with open(edbid_to_cve_file, "w", encoding="utf-8") as file_data:
                    json.dump(data, file_data, indent=2)
                global cve_to_exploit_mapping
                cve_to_exploit_mapping = {}
                for k, v in data.items():
                    for e in v:
                        cve_to_exploit_mapping[e] = cve_to_exploit_mapping.get(e, [])
                        cve_to_exploit_mapping[e].append(k)
                with open(cve_to_edbid_file, "w", encoding="utf-8") as file_data:
                    json.dump(cve_to_exploit_mapping, file_data, indent=2)
            time.sleep(0.005)
            bar()


def search_keyword(keyword):
    """
    Search via keywords
    :param keyword:
    :return: cve_data, []
    """
    result_list = []
    if not keyword:
        return []
    print(keyword)
    files = open(exploit_db_path + "/files_exploits.csv", encoding="utf-8")
    reader = csv.reader(files)
    next(reader)
    reader = list(reader)
    edb_count = len(reader)
    files.close()
    for i in range(edb_count):
        result = tuple(reader[i])[2]
        edb = tuple(reader[i])[0]
        if keyword.lower() in result.lower():
            if debug is True:
                print("Found")
            result_list.append(edb)
    cve_data = get_details_list(result_list)
    if cve_data:
        return cve_data
    else:
        return []


def get_details_list(id_list):
    """
    :param id_list:
    :return: result
    """
    result = []
    for i in id_list:
        edbid_data = get_edbid_details(i)
        result.append(edbid_data)
    return result


def get_edbid_details(edbid):
    """
    Get edbid details
    :param edbid:
    :return: result
    """
    files = open(current_path + "/data/exploit-database/files_exploits.csv", encoding="utf-8")
    reader = csv.reader(files)
    next(reader)
    result = []
    for row in reader:
        edb, file_name, description, date, author, platform, exploit_type, port = tuple(row)
        if edbid == edb:
            result.append(row)
    files.close()
    return result


def backup_files():
    """
    Backup json files
    :return: None
    """
    os.system("cp %s %s" % (edbid_to_cve_file, edbid_to_cve_file_backup))
    os.system("cp %s %s" % (cve_to_edbid_file, cve_to_edbid_file_backup))


def restore_files():
    """
    Restore json files
    :return: None
    """
    os.system("cp %s %s" % (edbid_to_cve_file_backup, edbid_to_cve_file))
    os.system("cp %s %s" % (cve_to_edbid_file_backup, cve_to_edbid_file))


def force_update():
    """
    Update all files
    :return: None
    """
    # Checks commit differences to determine if local files are outdated
    try:
        repo = git.Repo(exploit_db_path)
        current = repo.head.commit
        repo.remotes.origin.pull()
        if current != repo.head.commit:
            print("[!] Updating exploit-database")
            git.Git(exploit_db_path).pull('origin', 'master')
            update_db()
            hash_result = sha256(cve_to_edbid_file)
            write_hash(cve_to_edbid_file_hash_path, hash_result)
            hash_result = sha256(edbid_to_cve_file)
            write_hash(edbid_to_cve_file_hash_path, hash_result)
            backup_files()
        else:
            print("[!] exploit-database up-to-date")
    except:
        # Fallback to use existing files
        print("[!] Could not update exploit-db, using existing installation")


def run(cve_list):
    """
    :param cve_list:
    :return: True, results or False, None
    """
    open_file()
    for cve in cve_list:
        if cve.upper().startswith("CVE-"):
            results = search_cve(cve)
            if results:
                print("\n[!] " + cve + " Found! Getting the exploit PoC.")
                os.system("cp %s %s/downloads" % (results["exploit"], current_path))
                if os.path.exists(current_path + "/downloads/" + results["exploit"].rsplit("/", 1)[-1]):
                    pass
                else:
                    try:
                        download_url = "https://www.exploit-db.com/download/%s" % results["edbid"]
                        r = requests.get(download_url, headers=headers, timeout=10)
                        path = "%s/downloads/%s" % (current_path, results["exploit"].rsplit("/", 1)[-1])
                        with open(path, "wb") as f:
                            f.write(r.content)
                    except:
                        print("[!] Failed to download")
                        return False, None
                return True, results["exploit"]
            else:
                print("[!] Failed to get " + cve)
                return False, None
        # Not sure if this going to be used yet
        else:
            results = search_keyword(cve)
            if results:
                for i in results:
                    print(i)
                print(results)
                return True, results
            else:
                print("[!] Failed to get " + cve)
                return False, None


if __name__ == "__main__":
    debug = False
    cve_lists = ["CVE-2018-14592", "CVE-2003-0226", "CVE-2021-42013"]
    run(cve_lists)
