import os
import re
from .misc import *


class ExploitLoader:
    def __init__(self, exploit_path, exploit_type):
        """"
        Default constructor.
        :param exploit_path:
        :param exploit_type:
        :return: None.
        """
        self.exploit_path = exploit_path 
        self.exploit_type = exploit_type

    def open_file(self):
        """"
        Open a file and read all of its content.
        :param:
        :return lines:
        """
        with open(self.exploit_path) as f:
            lines = f.readlines()
        return lines

    def detect_python_parser_type(self, content):
        """"
        Detects the type of parser in a python exploit.
        :param content:
        :return "optparse":
        :return "argparse":
        :return "sys.argv":
        """
        for line in content:
            if "optparse" in line:
                return "optparse"
            
            if "argparse" in line:
                return "argparse"

            if "sys.argv" in line:
                return "sys.argv"

    def python_arguments_parser(self, content, parser_type):
        """"
        Attempt to try to find the arguments for the python exploit.
        :param content:
        :param parser_type:
        :return args_list:
        """
        args_list = []

        # If the parser type is "optparse".
        if parser_type == "optparse":
            pattern = "parser.add_option"
            for line in content: 
                if re.search(pattern, line):
                    args_list.append(line)
            return args_list

        # If the parser type is "argparse".
        elif parser_type == "argparse":
            pattern = "add_argument"
            for line in content:
                if re.search(pattern, line):
                    args_list.append(line)
            return args_list

        # If the parser type is "sys.argv".
        elif parser_type == "sys.argv":
            pattern_one = r".sage:.+"
            pattern_two = r".se:.+"
            for line in content: 
                if re.search(pattern_one, line):
                    args_list.append(line)
                elif re.search(pattern_two, line):
                    args_list.append(line)
            return args_list 

    def run_listener(self):
        """"
        Runs a reverse shell listener.
        :param:
        :return:
        """
        reverse_shell = input(print_yellow("\n[*] Set up listener (y/n): "))
        if reverse_shell.lower() == "y":
            port_number = input(print_yellow("\t[+] Enter a port number: "))
            os.system("gnome-terminal -e 'bash -c \"nc -nvlp %s; exec bash\"'" % port_number)

    def load_exploit_python(self, args_list, parser_type):
        """"
        Loads the python exploit based on the arguments provided by the user.
        :param args_list:
        :param parser_type:
        :return:
        """
        # If the parser type is "optparse".
        if parser_type == "optparse":
            arg_pattern = r"-[a-zA-Z]"
            desc_pattern = r"help=.+"
            user_args = [] 
            user_input = []
            for item in args_list:
                user_args.append((re.search(arg_pattern, item).group(0), re.search(desc_pattern, item).group(0)))
            
            # Prompt the user for the values 
            for item in user_args:
                query = item[1].split("=")[1].strip(r'"').strip(r"'")
                choice = input(print_yellow("\t[+] %s: " % query))
                arg = "%s %s" % (item[0], choice)
                user_input.append(arg)
            
            # Prompt the user if they want to set up a listener for the reverse shell. 
            self.run_listener()
        
            # If the exploit is a python file.
            command = "python3 %s" % self.exploit_path
            for item in user_input:
                command = command + " " + item
            os.system(command)

        # If the parser type is "argparse"
        elif parser_type == "argparse":
            arg_pattern = r"-[a-zA-Z]"
            desc_pattern = r"help=.+"
            user_args = []
            user_input = []
            for item in args_list:
                user_args.append((re.search(arg_pattern, item).group(0), re.search(desc_pattern, item).group(0)))

            # Prompt the user for the values
            for item in user_args:
                query = item[1].split("=")[1].strip(r'"').strip(r"'")
                choice = input(print_yellow("\t[+] %s: " % query))
                arg = "%s %s" % (item[0], choice)
                user_input.append(arg)

            # Prompt the user if they want to set up a listener for the reverse shell.
            self.run_listener()

            # If the exploit is a python file.
            command = "python3 %s" % self.exploit_path
            for item in user_input:
                command = command + " " + item
            os.system(command)

        # If the parser type is "sys.argv".
        elif parser_type == "sys.argv":
            command = "python3 %s" % self.exploit_path
            args = args_list[0].split("print")[1].strip("(").strip(")").strip("\n").strip(" ")
            user_input = input(print_yellow("\t[+] %s: " % args))
            command = command + " " + user_input
            os.system(command)

    # def load_exploit_c(self):
    #     command = "gcc %s -o %s" % (self.exploit_path, Path(self.exploit_path).name[:-2])
    #     os.system(command)
    #     command = "./%s" % Path(self.exploit_path).name[:-2]
    #     os.system(command)
    #
    # def load_exploit_cpp(self):
    #     command = "gcc %s -o %s" % (self.exploit_path, Path(self.exploit_path).name[:-2])
    #     os.system(command)
    #     command = "./%s" % Path(self.exploit_path).name[:-2]
    #     os.system(command)

    def check_file_ext(self):
        """"
        Checks the file extension of the exploit.
        :param:
        :return True:
        :return False:
        """
        valid_exts = ['py', 'c', 'cpp'] 
        if self.exploit_type not in valid_exts:
            print(print_red("[!] Exploit do not seem to be able to auto mount!"))
            return False 
        return True

    def run(self):
        """"
        Runs the exploit loader
        :param:
        :return True:
        :return False:
        """
        valid = self.check_file_ext()

        # Checks if the exploit can be auto-loaded.
        if valid:
            # If the file extension is ".py".
            if self.exploit_type == "py":
                lines = self.open_file()
                parser_type = self.detect_python_parser_type(lines)
                args_list = self.python_arguments_parser(lines, parser_type)
                self.load_exploit_python(args_list, parser_type)
                return True

            # If the file extension is ".c".
            elif self.exploit_type == "c":
                pass 

            # If the file extension is ".cpp".
            elif self.exploit_type == "cpp":
                pass 
        return False 
