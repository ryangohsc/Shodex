import os
import re
from pathlib import Path


current_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
arg_dict = {}


class ExploitLoader:
    def __init__(self, exploit_path, exploit_type):
        self.exploit_path = exploit_path 
        self.exploit_type = exploit_type

    def open_file(self):
        with open(self.exploit_path) as f:
            lines = f.readlines()
        return lines


    def detect_python_parser_type(self, content):
        for line in content:
            if "optparse" in line:
                return "optparse"
            
            if "argparse" in line:
                return "argparse"

            if "sys.argv" in line:
                return "sys.argv"


    def python_arguments_parser(self, content, parser_type):
        args_list = []
        if parser_type == "optparse":
            pattern = "parser.add_option"
            for line in content: 
                if re.search(pattern, line):
                    args_list.append(line)
            return args_list 
        
        elif parser_type == "sys.argv":
            pattern_one = r".sage:.+"
            pattern_two = r".se:.+"
            for line in content: 
                if re.search(pattern_one, line):
                    args_list.append(line)
                elif re.search(pattern_two, line):
                    args_list.append(line)
            return args_list 

    def load_exploit_python(self, args_list, parser_type):
        if parser_type == "optparse":
            arg_pattern = r"-[a-zA-Z]"
            desc_pattern = r"help=.+"
            user_args = [] 
            user_input = []
            for item in args_list:
                user_args.append((re.search(arg_pattern, item).group(0), re.search(desc_pattern, item).group(0)))
            
            # Prompt the user for the values 
            for item in user_args:
                query = item[1].split("=")[1].strip(r'"').strip(r"'")
                choice = input("\t[+] %s: " % query) 
                arg = "%s %s" % (item[0], choice)
                user_input.append(arg)
            
            # Prompt the user if they want to set up a listener for the reverse shell. 
            reverse_shell = input("\n[*] Set up listener (y/n): ")
            if reverse_shell.lower() == "y":
                port_number = input("\t[+] Enter a port number: ")
                os.system("gnome-terminal -e 'bash -c \"nc -nvlp {0}; exec bash\"'".format(port_number))
        
            # If the exploit is a python file.
            command = "python3 %s" % self.exploit_path
            for item in user_input:
                command = command + " " + item
            os.system(command)
        
        elif parser_type == "sys.argv":
            command = "python3 %s" % self.exploit_path
            args = args_list[0].split("print")[1].strip("(").strip(")").strip("\n").strip(" ")
            user_input = input("\t[+] %s: " % args)
            command = command + " " + user_input
            # os.system(command)

    def load_exploit_c(self):
        try:
            command = "gcc %s -o %s" % (self.exploit_path, Path(self.exploit_path).name[:-2])
            os.system(command)
            command = "./%s" % Path(self.exploit_path).name[:-2]
            os.system(command)
        except:
            print("gcc is not installed")

    
    def load_exploit_cpp(self):
        try:
            command = "gcc %s -o %s" % (self.exploit_path, Path(self.exploit_path).name[:-2])
            os.system(command)
            command = "./%s" % Path(self.exploit_path).name[:-2]
            os.system(command)
        except:
            print("gcc is not installed") 


    def check_file_ext(self):
        valid_exts = ['py', 'c', 'cpp'] 
        if self.exploit_type not in valid_exts:
            print("[!] Exploit do not seem to be able to auto mount!")
            return False 
        return True


    def run(self):
        valid = self.check_file_ext()
        if valid:
            if self.exploit_type == "py":
                lines = self.open_file()
                parser_type = self.detect_python_parser_type(lines)
                args_list = self.python_arguments_parser(lines, parser_type)
                self.load_exploit_python(args_list, parser_type)

                return True

            elif self.exploit_type == "c":
                pass 
            
            elif self.exploit_type == "cpp":
                pass 
        return False 



# if __name__ == "__main__":
#     exploit_file = current_path + "/data/local_exploits/49803.py"
#     run(exploit_file)
